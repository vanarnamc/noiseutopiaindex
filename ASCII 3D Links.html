<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Links</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="overlay" style="position: absolute; display: none; pointer-events: none; padding: 10px; background: rgba(0, 0, 0, 0.5); color: white;"></div>

    <script type="module">
import * as THREE from 'https://unpkg.com/three@latest/build/three.module.js';

var camera, scene, renderer, raycaster, mouse;
var INTERSECTED;
var grayShaderMaterial;

async function fetchLinks() {
    const response = await fetch('info.json');
    const data = await response.json();
    console.log("Fetched links:", data);
    return data.Sheet1;
}

function createGrayShaderMaterial() {
    return new THREE.ShaderMaterial({
        uniforms: {
            uTexture: { value: null }
        },
        vertexShader: `
            varying vec2 vUv;

            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D uTexture;
            varying vec2 vUv;

            void main() {
                vec4 color = texture(uTexture, vUv);
                float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                gl_FragColor = vec4(vec3(gray), color.a);
            }
        `,
        transparent: true,
    });
}

async function init() {
    const linksData = await fetchLinks();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.z = 1000;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xCF47D9);

    grayShaderMaterial = createGrayShaderMaterial();

    const loader = new THREE.TextureLoader();

    for (const entry of linksData) {
        if (entry.image && typeof entry.image === 'string' && !entry.image.includes('http')) {
            const imagePath = `assets/images/${entry.image}`;
            try {
                const texture = await loader.loadAsync(imagePath);
                const material = grayShaderMaterial.clone();
                material.uniforms.uTexture.value = texture;

                const sprite = new THREE.Sprite(material);
                sprite.scale.set(200, 200, 1);
                sprite.position.set(
                    Math.random() * 1600 - 800, 
                    Math.random() * 1200 - 600, 
                    Math.random() * 800 - 400
                );
                sprite.userData = {
                    url: entry.link,
                    title: entry.title,
                    name: entry.name
                };
                scene.add(sprite);
            } catch (error) {
                console.warn(`Could not load image at ${imagePath}:`, error);
            }
        } else {
            console.log(`Skipping entry due to undefined or invalid image:`, entry);
        }
    }

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('click', onDocumentClick, false);
    window.addEventListener('resize', onWindowResize, false);

    animate();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onDocumentMouseMove(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
}

function onDocumentClick(event) {
    event.preventDefault();
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length > 0) {
        const url = intersects[0].object.userData.url;
        if (url) window.open(url, '_blank');
    }
}

function animate() {
    requestAnimationFrame(animate);

    camera.position.x += (mouse.x * 500 - camera.position.x) * 0.05;
    camera.position.y += (-mouse.y * 500 - camera.position.y) * 0.05;
    camera.lookAt(scene.position);

    render();
}

function render() {
    camera.lookAt(scene.position);
    raycaster.setFromCamera(mouse, camera);
    renderer.render(scene, camera);
}

init();

  </script> 
  </body>
</html>
